### 八大内部排序算法

* 选择排序，插入排序，冒泡排序

  * 选择排序

  ```php
  /**
   *
  选择排序
  将要排序的对象分作两部份，一个是已排序的，一个是未排序的，从后端未排序部份选择一个最小值，并放入前端已排序部份的最后一个，例如：
  排序前：70 80 31 37 10 1 48 60 33 80
  [1] 80 31 37 10 70 48 60 33 80 选出最小值1
  [1 10] 31 37 80 70 48 60 33 80 选出最小值10
  [1 10 31] 37 80 70 48 60 33 80 选出最小值31
  [1 10 31 33] 80 70 48 60 37 80 ......
  [1 10 31 33 37] 70 48 60 80 80 ......
  [1 10 31 33 37 48] 70 60 80 80 ......
  [1 10 31 33 37 48 60] 70 80 80 ......
  [1 10 31 33 37 48 60 70] 80 80 ......
  [1 10 31 33 37 48 60 70 80] 80 ......
   * 选择排序
   */
  function selSort($num)
  {
  	for ($i=0; $i < count($num)-1; $i++) { 
  		$m = $i;

  		for ($j=$i+1; $j < count($num); $j++) { 
  			if ($num[$j] < $num[$m]) {
  				$m = $j;
  			}
  		}

  		if ($i != $m) {
  			list($num[$i], $num[$m]) = [$num[$m], $num[$i]];
  		}

  		echo '<br/>第'.($i+1).'次排序'.'<br/>';

  		foreach ($num as $key => $value) {
  			echo $value . ',';
  		}

  	}
  }
  ```

  * 插入排序

  ```php
  /**
   *
   *插入排序
  像是玩朴克一样，我们将牌分作两堆，每次从后面一堆的牌抽出最前端的牌，然后插入前面一堆牌的适当位置，例如：
  排序前：92 77 67 8 6 84 55 85 43 67
  [77 92] 67 8 6 84 55 85 43 67 将77插入92前
  [67 77 92] 8 6 84 55 85 43 67 将67插入77前
  [8 67 77 92] 6 84 55 85 43 67 将8插入67前
  [6 8 67 77 92] 84 55 85 43 67 将6插入8前
  [6 8 67 77 84 92] 55 85 43 67 将84插入92前
  [6 8 55 67 77 84 92] 85 43 67 将55插入67前
  [6 8 55 67 77 84 85 92] 43 67 ......
  [6 8 43 55 67 77 84 85 92] 67 ......
  [6 8 43 55 67 67 77 84 85 92] ......
   * 插入排序
   */
  function inSort($num)
  {
  	for ($i=1; $i < count($num); $i++) { 
  		$m = $i-1;

  		while ($num[$m+1] < $num[$m]) {

  			list($num[$m+1], $num[$m]) = [$num[$m], $num[$m+1]];
  			
  			$m--;

  			if ($m == -1) {
  				break;
  			}
  		}
  		echo '<br/>第'.($i).'次排序'.'<br/>';
  		
  		print_r($num);
  	}
  }
  ```

  * 冒泡排序

  ```php
  /**
   *顾名思义，就是排序时，最大的元素会如同气泡一样移至右端，其利用比较相邻元素的方法，将大的元素交换至右端，所以大的元素会不断的往右移动，直到适当的位置为止。基本的气泡排序法可以利用旗标的方式稍微减少一些比较的时间，当寻访完阵列后都没有发生任何的交换动作，表示排序已经完成，而无需再进行之后的回圈比较与交换动作，例如：
  排序前： 95 27 90 49 80 58 6 9 18 50
  		27 90 49 80 58 6 9 18 50 [95] 95浮出
  		27 49 80 58 6 9 18 50 [90 95] 90浮出
  		27 49 58 6 9 18 50 [80 90 95] 80浮出
  		27 49 6 9 18 50 [58 80 90 95] ......
  		27 6 9 18 49 [50 58 80 90 95] ......
  		6 9 18 27 [49 50 58 80 90 95] ......
  		6 9 18 [27 49 50 58 80 90 95] 由于接下来不会再发生交换动作，
   *
   * 冒泡排序 ,关心下半部分的比较
   */
  function bubSort($num)
  {
  	for ($i=0; $i < count($num)-1; $i++) { 

  		for ($j=0; $j < count($num)-$i-1; $j++) { 
  			if ($num[$j+1] > $num[$j]) {//和旁边的比较
  				list($num[$j+1], $num[$j]) = [$num[$j], $num[$j+1]];
  			}
  		}

  		echo '<br/>第'.($i+1).'次排序'.'<br/>';
  		
  		print_r($num);
  	}
  }
  ```

  ​

